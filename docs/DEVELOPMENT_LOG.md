# DND Character Creation - Development Log
项目地址：D:\DND_Character_Creation\dnd-character-creation

## 纲领使用说明

根据开发任务类型，优先参考以下对应章节：

1. **新功能开发**
   - 数据相关：参考 1.数据驱动设计、8.数据引用规范
   - 服务相关：参考 2.功能分配原则、12.服务层设计模式
   - UI相关：参考 9.UI交互规范、10.组件复用与模板

2. **问题修复**
   - 类型错误：参考 5.类型安全、7.类型系统设计原则
   - 数据问题：参考 4.接口一致性、8.数据引用规范
   - 运行时错误：参考 11.调试与排错流程、12.服务层设计模式

3. **代码重构**
   - 结构优化：参考 3.修改流程、6.代码组织
   - 类型重构：参考 4.接口一致性、7.类型系统设计原则
   - 组件重构：参考 9.UI交互规范、10.组件复用与模板

## 开发纲领与规范
应该遵循最小修改原则，只修改有问题的部分，避免影响已经正常工作的功能
1. **数据驱动设计**：
   - 类型定义必须与JSON数据结构保持兼容性
   - 可以在JSON结构基础上增加更严格的类型约束
   - 类型定义的改动必须确保与现有数据格式向后兼容
   - 实体数据与引用数据分离：
     - 实体：完整对象存储在独立文件中
     - 引用：仅包含 id 和 type 的引用对象
     - 示例：背景的熟练项使用引用格式 `{ id: "insight", type: "skill" }`

2. **功能分配原则**：
   - 计算和转换功能应放在数据主要来源的模块中
   - 跨模块的功能应在服务层实现，并明确注释依赖关系
   - 组件层只处理UI交互和数据展示，不包含业务逻辑
   - 数据加载顺序：
     - 服务初始化时必须加载所有依赖数据
     - 使用 `initialize()` 方法确保数据就绪
     - 组件使用前必须等待初始化完成

3. **修改流程**：
   - 遵循依赖链：数据(JSON) -> 类型(types) -> 服务(services) -> 组件(components)
   - 每层修改需要：
     1. 在创建或修改代码前，先查看 `types-definition.ts` 中的相关类型定义
     2. 单元测试通过
     3. TypeScript类型检查无误
     4. 相关功能测试验证完成
     5. 修改完成后再次核对 `types-definition.ts` 中的类型定义，确保类型使用正确
   - 允许并行开发不同模块，但合并时必须按依赖顺序
   - 要系统性解决而不要修补

4. **接口一致性**：
   - JSON字段名
   - TypeScript类型定义
   - 服务层方法名和返回类型
   - 组件中的属性名
   必须保持完全一致，发现不一致先统一再修改。
   - 引用类型命名规范：
     - 实体接口：`Entity`
     - 引用接口：`EntityReference`
     - 示例：`Proficiency` vs `ProficiencyReference`

5. **类型安全**：
   - 访问不同类型数据前先进行类型收窄
   - 使用联合类型前检查属性存在性
   - 处理可选属性时考虑不存在情况
   - 访问数组或集合时检查边界
   - 引用类型处理：
     - 必须通过服务层方法解析引用
     - 组件层不直接使用引用的 id
   - 异步操作处理：
     - 服务初始化必须使用 async/await
     - 组件中等待服务初始化完成
     - 提供加载状态反馈
   - 状态管理：
     - 使用状态标志追踪初始化
     - 统一的错误处理机制
     - 避免空值传播

6. **代码组织**：
   - 新建文件前评估是否可以复用/融入现有文件
   - 相关功能应该放在同一目录下
   - 保持目录结构扁平，最多三层嵌套
   - 文件命名要能清晰表达其功能
   - 数据文件组织：
     - 每类数据独立目录：`public/data/<category>/`
     - 实体数据集中存储：`public/data/<category>/<entity>.json`
     - 引用数据随父对象存储

7. **类型系统设计原则**：
   - 定义明确的数据接口，例如：
```typescript
// ✓ 好的设计：明确的数据存储形式
interface Character {
  background: Background;  // 存储完整对象，频繁访问
  equippedItems: string[];  // 存储ID，按需加载
}

// ✗ 糟糕的设计：类型不一致
interface Character {
  background: string | Background;  // 混合使用ID和对象
}
```

   - 避免类型断言，使用类型守卫：
```typescript
// ✓ 好的做法：使用类型守卫
if ('id' in background) {
  handleBackground(background.id);
}

// ✗ 糟糕的做法：使用类型断言
handleBackground((background as any).id);
```

8. **数据引用规范**：
   - 引用对象必须包含：
     ```typescript
     interface Reference {
       id: string;    // 唯一标识符
       type: string;  // 引用类型
     }
     ```
   - 引用解析流程：
     1. 服务层加载实体数据
     2. 组件通过服务方法解析引用
     3. 处理找不到实体的情况
   - 性能考虑：
     - 频繁访问的数据使用完整对象
     - 偶尔访问的数据使用引用

9. **UI交互规范**：
   - 交互模式统一：
     - Tooltip/Popper统一使用hover触发
     - 弹出层统一使用transition动画
     - 点击行为保持一致性（如确认、取消按钮位置）
   - 组件配置完整性：
     - Material-UI组件必须配置完整的属性
     - Popper必须包含：placement、transition、modifiers
     - Dialog必须包含：标题、操作按钮、关闭方式
   - 状态管理简化：
     - 避免复杂的状态组合（如locked + open）
     - 优先使用受控组件
     - 状态更新保持原子性

10. **组件复用与模板**：
    - 常用交互模式封装：
      ```typescript
      // tooltip模板
      interface TooltipState {
        open: boolean;
        anchorEl: HTMLElement | null;
        text: string;
      }
      
      // 标准hover处理
      const handleTooltipOpen = (event: React.MouseEvent<HTMLElement>, text: string) => {
        setTooltipState({
          open: true,
          anchorEl: event.currentTarget,
          text
        });
      };
      
      // 标准Popper配置
      const standardPopperProps = {
        transition: true,
        modifiers: [
          {
            name: 'offset',
            options: { offset: [0, 8] }
          },
          {
            name: 'flip',
            enabled: true
          },
          {
            name: 'preventOverflow',
            enabled: true,
            options: {
              boundariesElement: 'viewport'
            }
          }
        ]
      };
      ```
    - 复用检查清单：
      1. 是否有类似功能的现有组件
      2. 是否可以抽象为通用组件
      3. 是否符合项目交互规范
      4. 是否包含完整的类型定义
      5. 是否有清晰的使用文档

11. **调试与排错流程**：
    - 组件问题定位：
      1. 检查数据流：服务层 -> 状态管理 -> 渲染
      2. 检查事件处理：触发条件 -> 状态更新 -> UI响应
      3. 检查组件配置：必要属性 -> 样式设置 -> 交互配置
    - 常见问题快速检查：
      1. 服务是否正确初始化
      2. 数据是否正确加载
      3. 事件处理器是否正确绑定
      4. 组件配置是否完整
      5. 状态更新是否正确
    - 修复验证：
      1. 确保修复全局一致
      2. 验证相似组件
      3. 更新相关文档
      4. 添加防护措施
    - 系统性解决：
      1. 识别问题根源而不是表象
      2. 评估影响范围
      3. 设计通用解决方案
      4. 添加类型约束和运行时检查
      5. 更新开发规范防止类似问题

12. **服务层设计模式**：
    - 初始化流程：
      1. 构造函数只接收依赖
      2. 使用 async initialize() 方法
      3. 所有初始化逻辑集中处理
      4. 提供初始化状态检查
    - 错误处理：
      1. 统一的错误检查机制
      2. 明确的错误消息
      3. 服务状态验证
    - 状态管理：
      1. 私有状态封装
      2. 公共访问方法
      3. 状态一致性检查
    - 依赖管理：
      1. 显式声明依赖
      2. 依赖初始化检查
      3. 循环依赖预防

### 当前进度

#### 已完成
1. **基础架构**
   - TypeScript 项目配置
   - React 组件结构
   - 路由系统
   - 状态管理
   - 本地存储系统

2. **数据结构**
   - 种族数据结构
   - 职业数据结构
   - 背景数据结构
   - 熟练项数据结构
   - 装备系统数据结构
   - 法术系统数据结构
   - 专长系统数据结构
   - 引用类型系统

3. **核心服务**
   - GameDataService 单例模式实现
   - AbilityService 属性计算服务
   - LevelingService 等级系统服务
   - SpellService 法术系统服务
   - CharacterExportService 角色导出服务
   - LocalStorageService 本地存储服务
   - MasteryProficienciesService 熟练项服务
   - SkillProficiencyService 技能熟练服务
   - 数据加载和初始化流程
   - 错误处理和日志系统
   - 实体引用解析系统

4. **UI组件**
   - 种族选择界面
   - 职业选择界面
   - 背景选择界面
   - 属性分配界面
   - 熟练项展示组件
   - 法术选择界面
   - 装备管理界面
   - 等级提升界面
   - 专长选择界面
   - 角色导出导入功能
   - 角色管理界面

5. **数据文件**
   - 种族数据文件
   - 职业数据文件
   - 背景数据文件
   - 熟练项数据文件
   - 法术数据文件
   - 装备数据文件
   - 专长数据文件
   - 规则数据文件

6. **UI优化**
   - 统一的tooltip实现
   - 特性描述的分层展示
   - 熟练项展示优化
   - 属性选择界面布局
   - 法术选择界面优化
   - 装备管理界面优化
   - 等级提升流程优化

#### 进行中
1. **功能优化**
   - 角色管理系统增强
   - 多语言支持完善
   - 移动端适配
   - UI/UX改进
   - 性能优化

2. **数据完善**
   - 扩充预设角色
   - 补充法术描述
   - 完善装备数据
   - 添加更多专长选项

3. **用户体验**
   - 角色创建引导优化
   - 错误提示优化
   - 加载状态优化
   - 响应式布局改进

#### 待开发
1. **新功能**
   - 角色打印功能
   - 角色分享功能
   - 自定义内容支持
   - 战斗模拟系统
   - 角色头像生成

2. **系统增强**
   - 云端存储支持
   - 多设备同步
   - 版本控制系统
   - 角色历史记录

3. **社区功能**
   - 角色展示平台
   - 自定义内容分享
   - 社区反馈系统
   - 数据统计分析

## 理想中完整的角色创建流程与布局

### 布局结构

界面从左到右分为四个区块，比例布局如下：
- 区块一：导航栏（窄竖条）
- 区块二：内容区（2/4宽度）
- 区块三：角色预览（1/4宽度）
- 区块四：属性面板（1/4宽度）

### 区块功能

1. **区块一（导航栏）**
   - 动态标签系统，根据选择显示相应标签
   - 基础标签：出身、种族、职业、背景、属性
   - 动态标签：亚种、副职、戏法、血脉等（根据选择出现）

2. **区块二（内容区）**
   - 动态内容区，随区块一标签切换而变化
   - 包含选项LOGO、详细说明、特性列表等
   - 支持悬浮提示和多层级说明系统

3. **区块三（角色预览）**
   - 展示角色2D立绘
   - 随选择实时更新外观

4. **区块四（属性面板）**
   - 固定布局，从上到下展示：
     - 职业LOGO
     - 种族及亚种信息
     - 等级信息
     - 职业及副职、兼职
     - 六维属性（标注关键属性）
     - 战斗相关属性
     - 技能与熟练项列表

### 创建流程

1. **出身选择**
   - 选择自定义/预设角色
   - 预设角色提供介绍

2. **种族选择**
   - 展示所有可选种族
   - 支持亚种选择
   - 包含种族特性说明
   - 特殊能力选择（如种族戏法、血脉等））

3. **职业选择**
   - 展示所有可选职业
   - 副职选择（如适用）
   - 兼职选择（如适用）
   - 职业特性选择
   - 战斗风格/法术等特殊选项

4. **背景选择**
   - 背景故事与特性
   - 相关熟练项展示

5. **属性分配**
   - 购点系统（27点）
   - 属性加值分配（+1/+2）
   - 技能熟练项选择
   - 支持推荐值快速分配

### 交互特性

1. **悬浮提示系统**
   - 术语解释自动弹出
   - 支持T键锁定说明
   - 支持多层级解释
   - 点击空白处关闭所有提示

2. **实时更新**
   - 选择实时反映在预览区
   - 属性面板动态更新
   - 自动计算相关数值

3. **智能提示**
   - 基于职业的推荐属性
   - 自动提示可选熟练项
   - 显示选择限制和要求

### 特殊规则

1. **多职业规则**
   - 二级后开放兼职选项
   - 保持与主职业相同的选择逻辑

2. **特殊职业规则**
   - 游荡者专精系统
   - 术士血脉选择
   - 战士战斗风格

## 项目架构说明

### 更新后的文件结构

```
src/
├── components/                          # 组件目录
│   ├── CharacterManager/               # 角色管理组件目录
│   │   ├── CharacterList.tsx          # 角色列表：展示和管理已保存的角色
│   │   ├── CharacterCard.tsx          # 角色卡片：单个角色的预览和操作界面
│   │   └── CharacterTabs.tsx          # 角色标签页：管理多个角色的切换显示
│   └── CharacterCreator/               # 角色创建功能的根组件目录
│       ├── context.tsx                # 角色创建的上下文管理：包含角色状态、创建步骤和验证逻辑
│       ├── index.tsx                  # 主组件：整合所有子组件，管理创建流程和状态更新
│       ├── layout/                    # 布局组件目录
│       │   ├── Navigation.tsx         # 导航栏：步骤导航和进度展示
│       │   └── Stats.tsx              # 属性面板：实时更新的角色属性统计
│       └── steps/                     # 创建步骤组件目录
│           ├── AbilityScoreAllocation.tsx  # 属性分配：属性值分配和调整
│           ├── ASISelection.tsx            # 属性值提升选择：等级提升时的属性加点
│           ├── Appearance.tsx              # 外观设置：角色外观定制
│           ├── Background.tsx              # 背景选择：角色背景和相关特性
│           ├── CharacterControl.tsx        # 角色控制：基本信息管理
│           ├── ClassSelection.tsx          # 职业选择：职业和相关特性
│           ├── FeatSelection.tsx           # 专长选择：专长系统实现
│           ├── InventorySelection.tsx      # 装备选择：装备管理系统
│           ├── LevelSelection.tsx          # 等级选择：等级提升和相关特性
│           ├── MasteryProficiencies.tsx    # 熟练项管理：技能和工具熟练
│           ├── Notes.tsx                   # 笔记系统：角色笔记和记录
│           ├── Origin.tsx                  # 起源设置：角色背景故事
│           ├── RaceSelection.tsx           # 种族选择：种族和亚种选择
│           ├── SkillProficiencies.tsx      # 技能熟练：技能选择和管理
│           └── SpellSelection.tsx          # 法术选择：法术系统实现

├── services/                           # 服务层目录
│   ├── AbilityService.ts              # 属性系统服务：处理属性计算、调整值和验证
│   ├── CharacterExportService.ts      # 角色导出服务：处理角色数据的导入导出
│   ├── GameDataService.ts             # 游戏数据服务：管理所有游戏数据的加载和访问
│   ├── LevelingService.ts             # 等级系统服务：处理等级提升和相关计算
│   ├── LocalStorageService.ts         # 本地存储服务：管理角色数据的本地存储
│   ├── MasteryProficienciesService.ts # 熟练项服务：管理武器、工具等熟练项
│   ├── SkillProficiencyService.ts     # 技能熟练服务：管理技能熟练项
│   └── SpellService.ts                # 法术服务：处理法术系统相关功能

├── types/                             # 类型定义目录
│   ├── ability.ts                     # 属性系统类型：六大属性和相关计算
│   ├── background.ts                  # 背景系统类型：角色背景定义
│   ├── character.ts                   # 角色数据类型：完整角色模型
│   ├── character-management.ts        # 角色管理类型：角色列表和操作
│   ├── Class.ts                       # 职业系统类型：职业特性和进阶
│   ├── equipment.ts                   # 装备系统类型：武器、防具等
│   ├── feat.ts                        # 专长系统类型：专长定义和效果
│   ├── language.ts                    # 语言系统类型：语言定义
│   ├── leveling.ts                    # 等级系统类型：等级和经验值
│   ├── proficiency.ts                 # 熟练项类型：技能和工具熟练
│   ├── race.ts                        # 种族系统类型：种族和亚种特性
│   ├── spell.ts                       # 法术系统类型：法术定义和效果
│   └── types-definition.ts            # 核心类型定义：共享类型和接口

└── utils/                             # 工具函数目录
    └── theme.ts                       # 主题配置：Material-UI 主题设置

public/
└── data/                              # 游戏数据目录
    ├── Backgrounds/                    # 背景数据：各种角色背景
    ├── Classes/                        # 职业数据：各个职业的详细信息
    ├── Equipment/                      # 装备数据：武器、防具等
    ├── feats/                         # 专长数据：各种专长的定义
    ├── image/                         # 图片资源：界面使用的各种图片
    ├── localization/                  # 本地化数据：多语言支持文件
    ├── Other proficiency/             # 其他熟练项数据
    ├── presets/                       # 预设数据：预设角色模板
    ├── races/                         # 种族数据：各个种族的详细信息
    ├── rules/                         # 规则数据：游戏规则定义
    ├── skill proficiencies/           # 技能熟练数据
    └── spells/                        # 法术数据：法术详细信息

## 开发指南

### 1. 开发流程规范

#### 1.1 核心原则

1. **最小修改原则**
   - 优先修改现有文件，避免创建新文件
   - 新文件创建必须经过审核确认
   - 修改范围应当最小化，避免不必要的改动

2. **兼容性原则**
   - 修改不应影响现有功能
   - 保持向后兼容
   - 确保接口稳定性

3. **系统性解决原则**
   - 解决根本问题，而不是表面现象
   - 避免临时性修复
   - 建立长期有效的解决方案

#### 1.2 开发流程

1. **任务分析阶段**
   - 完整理解任务范围和技术要求
   - 分析任务类型（新功能/错误修复/重构）
   - 识别涉及的文件和功能点
   - 确定预期结果

2. **范围确定阶段**
   - 明确修改范围
   - 确定技术规范
   - 梳理接口关系
   - 评估影响范围

3. **类型系统分析阶段**
   - 理解并确保类型安全
   - 分析类型依赖关系
   - 确定类型约束
   - 验证类型完整性

4. **代码修改阶段**
   - 制定修改计划
   - 实现功能
   - 保持类型安全
   - 记录技术债务

5. **验证确保阶段**
   - 类型检查
   - 功能测试
   - 代码审查
   - 文档更新

### 2. 代码规范

#### 2.1 TypeScript 规范

1. **类型定义**
   - 使用 interface 而不是 type（除非必要）
   - 明确定义所有参数和返回值类型
   - 避免使用 any
   - 合理使用泛型

2. **命名规范**
   - 接口名使用 I 前缀（如 ICharacter）
   - 类型名使用 T 前缀（如 TAbility）
   - 枚举名使用 E 前缀（如 EClass）
   - 常量使用全大写（如 MAX_LEVEL）

3. **文件组织**
   - 相关的类型定义放在同一文件
   - 导出的类型放在文件顶部
   - 工具类型放在类型定义文件底部
   - 每个文件职责单一

#### 2.2 React 组件规范

1. **组件结构**
   - 使用函数组件和 hooks
   - 组件职责单一
   - 提取公共逻辑到 hooks
   - 避免过深的组件嵌套

2. **状态管理**
   - 使用 Context 管理全局状态
   - 使用 useState 管理局部状态
   - 避免状态提升过高
   - 合理使用 useMemo 和 useCallback

3. **性能优化**
   - 及时清理副作用
   - 避免不必要的重渲染
   - 使用 React.memo 优化性能
   - 合理使用 useEffect 依赖数组

### 3. 数据管理规范

#### 3.1 游戏数据

1. **数据结构**
   - JSON 格式存储
   - 按功能模块分类
   - 保持数据结构扁平
   - 避免循环引用

2. **数据加载**
   - 懒加载非必要数据
   - 缓存频繁使用的数据
   - 处理加载失败情况
   - 提供加载状态反馈

3. **数据验证**
   - 运行时类型检查
   - 数据完整性验证
   - 边界条件处理
   - 错误信息友好化

#### 3.2 角色数据

1. **数据存储**
   - 使用 LocalStorage 持久化
   - 定期自动保存
   - 提供导入导出功能
   - 版本控制和迁移

2. **数据更新**
   - 原子性更新操作
   - 保持数据一致性
   - 提供撤销/重做功能
   - 处理并发更新

3. **数据验证**
   - 完整性检查
   - 规则合法性验证
   - 数值范围检查
   - 依赖关系验证

### 4. 错误处理规范

1. **错误分类**
   - 类型错误
   - 运行时错误
   - 数据错误
   - 网络错误

2. **错误处理策略**
   - 使用 try-catch 捕获异常
   - 提供友好的错误提示
   - 记录错误日志
   - 保护用户数据

3. **错误恢复**
   - 自动恢复机制
   - 手动恢复选项
   - 数据备份还原
   - 错误状态清理

### 5. 测试规范

1. **单元测试**
   - 测试关键业务逻辑
   - 测试边界条件
   - 测试错误处理
   - 保持测试独立性

2. **集成测试**
   - 测试组件交互
   - 测试数据流
   - 测试状态管理
   - 测试性能表现

3. **端到端测试**
   - 测试主要用户流程
   - 测试数据持久化
   - 测试浏览器兼容性
   - 测试响应式布局

### 6. 文档规范

1. **代码注释**
   - 关键逻辑说明
   - 复杂算法解释
   - 类型定义说明
   - TODO 标记规范

2. **API 文档**
   - 接口说明
   - 参数描述
   - 返回值说明
   - 使用示例

3. **更新日志**
   - 版本号规范
   - 更新内容描述
   - 破坏性更新说明
   - 升级指南

## Change Log

### v1.1.0 (2024-01-16)

#### 新增功能
- 添加角色管理功能
  - 实现角色列表展示
  - 添加角色卡片预览
  - 支持多角色标签页切换
- 扩展角色创建功能
  - 添加专长选择系统
  - 添加装备管理系统
  - 添加笔记系统
  - 添加起源设置
  - 完善熟练项管理
  - 添加法术选择系统
- 增强数据管理
  - 添加本地存储服务
  - 实现角色数据导入导出
  - 添加预设角色模板

#### 优化改进
- 重构文件结构
  - 优化组件目录结构
  - 规范化服务层架构
  - 完善类型定义系统
- 增强类型安全
  - 完善接口定义
  - 添加类型验证
  - 优化类型推导
- 提升用户体验
  - 优化导航交互
  - 改进数据展示
  - 增强错误提示

#### 问题修复
- 修复属性值计算错误
- 修复等级提升时的数据更新问题
- 修复角色导出时的数据完整性问题
- 修复多个UI渲染问题

### v1.0.0 (2023-12-25)

#### 初始功能
- 基础角色创建系统
  - 种族选择
  - 职业选择
  - 背景选择
  - 属性分配
  - 技能选择
- 核心数据管理
  - 游戏数据服务
  - 属性计算服务
  - 等级系统服务
- 基础UI框架
  - 创建流程导航
  - 属性面板显示
  - 选项列表展示

#### 技术基础
- TypeScript 项目配置
- React 组件架构
- 数据管理方案
- 开发规范制定

[Previous entries...]
