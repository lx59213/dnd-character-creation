# DND Character Creation - Development Log
项目地址：D:\DND_Character_Creation\dnd-character-creation

## 纲领使用说明

根据开发任务类型，优先参考以下对应章节：

1. **新功能开发**
   - 数据相关：参考 1.数据驱动设计、8.数据引用规范
   - 服务相关：参考 2.功能分配原则、12.服务层设计模式
   - UI相关：参考 9.UI交互规范、10.组件复用与模板

2. **问题修复**
   - 类型错误：参考 5.类型安全、7.类型系统设计原则
   - 数据问题：参考 4.接口一致性、8.数据引用规范
   - 运行时错误：参考 11.调试与排错流程、12.服务层设计模式

3. **代码重构**
   - 结构优化：参考 3.修改流程、6.代码组织
   - 类型重构：参考 4.接口一致性、7.类型系统设计原则
   - 组件重构：参考 9.UI交互规范、10.组件复用与模板

## 开发纲领与规范
应该遵循最小修改原则，只修改有问题的部分，避免影响已经正常工作的功能
1. **数据驱动设计**：
   - 类型定义必须与JSON数据结构保持兼容性
   - 可以在JSON结构基础上增加更严格的类型约束
   - 类型定义的改动必须确保与现有数据格式向后兼容
   - 实体数据与引用数据分离：
     - 实体：完整对象存储在独立文件中
     - 引用：仅包含 id 和 type 的引用对象
     - 示例：背景的熟练项使用引用格式 `{ id: "insight", type: "skill" }`

2. **功能分配原则**：
   - 计算和转换功能应放在数据主要来源的模块中
   - 跨模块的功能应在服务层实现，并明确注释依赖关系
   - 组件层只处理UI交互和数据展示，不包含业务逻辑
   - 数据加载顺序：
     - 服务初始化时必须加载所有依赖数据
     - 使用 `initialize()` 方法确保数据就绪
     - 组件使用前必须等待初始化完成

3. **修改流程**：
   - 遵循依赖链：数据(JSON) -> 类型(types) -> 服务(services) -> 组件(components)
   - 每层修改需要：
     1. 在创建或修改代码前，先查看 `types-definition.ts` 中的相关类型定义
     2. 单元测试通过
     3. TypeScript类型检查无误
     4. 相关功能测试验证完成
     5. 修改完成后再次核对 `types-definition.ts` 中的类型定义，确保类型使用正确
   - 允许并行开发不同模块，但合并时必须按依赖顺序
   - 要系统性解决而不要修补

4. **接口一致性**：
   - JSON字段名
   - TypeScript类型定义
   - 服务层方法名和返回类型
   - 组件中的属性名
   必须保持完全一致，发现不一致先统一再修改。
   - 引用类型命名规范：
     - 实体接口：`Entity`
     - 引用接口：`EntityReference`
     - 示例：`Proficiency` vs `ProficiencyReference`

5. **类型安全**：
   - 访问不同类型数据前先进行类型收窄
   - 使用联合类型前检查属性存在性
   - 处理可选属性时考虑不存在情况
   - 访问数组或集合时检查边界
   - 引用类型处理：
     - 必须通过服务层方法解析引用
     - 组件层不直接使用引用的 id
   - 异步操作处理：
     - 服务初始化必须使用 async/await
     - 组件中等待服务初始化完成
     - 提供加载状态反馈
   - 状态管理：
     - 使用状态标志追踪初始化
     - 统一的错误处理机制
     - 避免空值传播

6. **代码组织**：
   - 新建文件前评估是否可以复用/融入现有文件
   - 相关功能应该放在同一目录下
   - 保持目录结构扁平，最多三层嵌套
   - 文件命名要能清晰表达其功能
   - 数据文件组织：
     - 每类数据独立目录：`public/data/<category>/`
     - 实体数据集中存储：`public/data/<category>/<entity>.json`
     - 引用数据随父对象存储

7. **类型系统设计原则**：
   - 定义明确的数据接口，例如：
```typescript
// ✓ 好的设计：明确的数据存储形式
interface Character {
  background: Background;  // 存储完整对象，频繁访问
  equippedItems: string[];  // 存储ID，按需加载
}

// ✗ 糟糕的设计：类型不一致
interface Character {
  background: string | Background;  // 混合使用ID和对象
}
```

   - 避免类型断言，使用类型守卫：
```typescript
// ✓ 好的做法：使用类型守卫
if ('id' in background) {
  handleBackground(background.id);
}

// ✗ 糟糕的做法：使用类型断言
handleBackground((background as any).id);
```

8. **数据引用规范**：
   - 引用对象必须包含：
     ```typescript
     interface Reference {
       id: string;    // 唯一标识符
       type: string;  // 引用类型
     }
     ```
   - 引用解析流程：
     1. 服务层加载实体数据
     2. 组件通过服务方法解析引用
     3. 处理找不到实体的情况
   - 性能考虑：
     - 频繁访问的数据使用完整对象
     - 偶尔访问的数据使用引用

9. **UI交互规范**：
   - 交互模式统一：
     - Tooltip/Popper统一使用hover触发
     - 弹出层统一使用transition动画
     - 点击行为保持一致性（如确认、取消按钮位置）
   - 组件配置完整性：
     - Material-UI组件必须配置完整的属性
     - Popper必须包含：placement、transition、modifiers
     - Dialog必须包含：标题、操作按钮、关闭方式
   - 状态管理简化：
     - 避免复杂的状态组合（如locked + open）
     - 优先使用受控组件
     - 状态更新保持原子性

10. **组件复用与模板**：
    - 常用交互模式封装：
      ```typescript
      // tooltip模板
      interface TooltipState {
        open: boolean;
        anchorEl: HTMLElement | null;
        text: string;
      }
      
      // 标准hover处理
      const handleTooltipOpen = (event: React.MouseEvent<HTMLElement>, text: string) => {
        setTooltipState({
          open: true,
          anchorEl: event.currentTarget,
          text
        });
      };
      
      // 标准Popper配置
      const standardPopperProps = {
        transition: true,
        modifiers: [
          {
            name: 'offset',
            options: { offset: [0, 8] }
          },
          {
            name: 'flip',
            enabled: true
          },
          {
            name: 'preventOverflow',
            enabled: true,
            options: {
              boundariesElement: 'viewport'
            }
          }
        ]
      };
      ```
    - 复用检查清单：
      1. 是否有类似功能的现有组件
      2. 是否可以抽象为通用组件
      3. 是否符合项目交互规范
      4. 是否包含完整的类型定义
      5. 是否有清晰的使用文档

11. **调试与排错流程**：
    - 组件问题定位：
      1. 检查数据流：服务层 -> 状态管理 -> 渲染
      2. 检查事件处理：触发条件 -> 状态更新 -> UI响应
      3. 检查组件配置：必要属性 -> 样式设置 -> 交互配置
    - 常见问题快速检查：
      1. 服务是否正确初始化
      2. 数据是否正确加载
      3. 事件处理器是否正确绑定
      4. 组件配置是否完整
      5. 状态更新是否正确
    - 修复验证：
      1. 确保修复全局一致
      2. 验证相似组件
      3. 更新相关文档
      4. 添加防护措施
    - 系统性解决：
      1. 识别问题根源而不是表象
      2. 评估影响范围
      3. 设计通用解决方案
      4. 添加类型约束和运行时检查
      5. 更新开发规范防止类似问题

12. **服务层设计模式**：
    - 初始化流程：
      1. 构造函数只接收依赖
      2. 使用 async initialize() 方法
      3. 所有初始化逻辑集中处理
      4. 提供初始化状态检查
    - 错误处理：
      1. 统一的错误检查机制
      2. 明确的错误消息
      3. 服务状态验证
    - 状态管理：
      1. 私有状态封装
      2. 公共访问方法
      3. 状态一致性检查
    - 依赖管理：
      1. 显式声明依赖
      2. 依赖初始化检查
      3. 循环依赖预防

### 当前进度

#### 已完成
1. **基础架构**
   - TypeScript 项目配置
   - React 组件结构
   - 路由系统
   - 状态管理

2. **数据结构**
   - 种族数据结构
   - 职业数据结构
   - 背景数据结构
   - 熟练项数据结构
   - 引用类型系统

3. **核心服务**
   - GameDataService 单例模式实现
   - 数据加载和初始化流程
   - 错误处理和日志系统
   - 实体引用解析系统

4. **UI组件**
   - 种族选择界面
   - 职业选择界面
   - 背景选择界面
   - 属性分配界面
   - 熟练项展示组件

5. **数据文件**
   - 种族数据文件
   - 职业数据文件
   - 背景数据文件
   - 熟练项数据文件

6. **UI优化**
   - 统一的tooltip实现
     - 使用hover触发
     - 完整的Popper配置
     - 优化的状态管理
   - 特性描述的分层展示
     - 正文显示完整描述
     - tooltip显示机制效果
   - 熟练项展示优化
   - 属性选择界面布局

#### 进行中
1. **数据结构优化**
   - 完善引用类型系统
   - 统一数据访问模式
   - 规范化数据文件结构

2. **服务层增强**
   - 优化数据加载性能
   - 完善错误处理机制
   - 添加数据验证

3. **UI改进**
   - 优化组件加载状态
   - 增强错误提示
   - 改进用户交互体验

#### 待开发
1. **功能模块**
   - 装备系统
   - 法术系统
   - 特性系统
   - 职业资源管理
   - 子职业选择

2. **性能优化**
   - 数据缓存机制
   - 按需加载策略
   - 组件渲染优化

3. **用户体验**
   - 角色创建引导
   - 保存和加载功能
   - 打印和导出功能

## 理想中完整的角色创建流程与布局

### 布局结构

界面从左到右分为四个区块，比例布局如下：
- 区块一：导航栏（窄竖条）
- 区块二：内容区（2/4宽度）
- 区块三：角色预览（1/4宽度）
- 区块四：属性面板（1/4宽度）

### 区块功能

1. **区块一（导航栏）**
   - 动态标签系统，根据选择显示相应标签
   - 基础标签：出身、种族、职业、背景、属性
   - 动态标签：亚种、副职、戏法、血脉等（根据选择出现）

2. **区块二（内容区）**
   - 动态内容区，随区块一标签切换而变化
   - 包含选项LOGO、详细说明、特性列表等
   - 支持悬浮提示和多层级说明系统

3. **区块三（角色预览）**
   - 展示角色2D立绘
   - 随选择实时更新外观

4. **区块四（属性面板）**
   - 固定布局，从上到下展示：
     - 职业LOGO
     - 种族及亚种信息
     - 等级信息
     - 职业及副职、兼职
     - 六维属性（标注关键属性）
     - 战斗相关属性
     - 技能与熟练项列表

### 创建流程

1. **出身选择**
   - 选择自定义/预设角色
   - 预设角色提供介绍

2. **种族选择**
   - 展示所有可选种族
   - 支持亚种选择
   - 包含种族特性说明
   - 特殊能力选择（如种族戏法、血脉等））

3. **职业选择**
   - 展示所有可选职业
   - 副职选择（如适用）
   - 兼职选择（如适用）
   - 职业特性选择
   - 战斗风格/法术等特殊选项

4. **背景选择**
   - 背景故事与特性
   - 相关熟练项展示

5. **属性分配**
   - 购点系统（27点）
   - 属性加值分配（+1/+2）
   - 技能熟练项选择
   - 支持推荐值快速分配

### 交互特性

1. **悬浮提示系统**
   - 术语解释自动弹出
   - 支持T键锁定说明
   - 支持多层级解释
   - 点击空白处关闭所有提示

2. **实时更新**
   - 选择实时反映在预览区
   - 属性面板动态更新
   - 自动计算相关数值

3. **智能提示**
   - 基于职业的推荐属性
   - 自动提示可选熟练项
   - 显示选择限制和要求

### 特殊规则

1. **多职业规则**
   - 二级后开放兼职选项
   - 保持与主职业相同的选择逻辑

2. **特殊职业规则**
   - 游荡者专精系统
   - 术士血脉选择
   - 战士战斗风格

## 项目架构说明

### 更新后的文件结构

```
src/
├── components/
│   └── CharacterCreator/                # 角色创建功能的根组件目录
│       ├── context.tsx                  # 角色创建的上下文管理：包含角色状态、创建步骤和验证逻辑
│       ├── index.tsx                    # 主组件：整合所有子组件，管理创建流程和状态更新
│       ├── layout/                      # 布局组件目录：定义整体UI结构
│       │   ├── Appearance.tsx           # 区块三，角色外貌预览：3D模型展示和自定义
│       │   ├── Content.tsx              # 区块二，选项展示区：当前步骤的具体选项和操作界面
│       │   ├── Navigation.tsx           # 区块一，导航栏：步骤导航和进度展示
│       │   └── Stats.tsx                # 区块四，属性面板：实时更新的角色属性统计
│       └── steps/                       # 创建步骤组件目录：每个步骤的具体实现
│           ├── ClassSelection.tsx        # 职业选择步骤：包含职业列表、详情和选择逻辑
│           ├── BackgroundSelection.tsx   # 背景选择步骤：包含背景列表、详情和选择逻辑
│           ├── AbilityAllocation.tsx     # 属性分配步骤：负责属性分配和熟练项选择
│           └── RaceSelection.tsx         # 种族选择步骤：包含种族列表、特性展示和选择逻辑
│
├── services/                            # 服务层目录：处理数据和业务逻辑
│   ├── GameDataService.ts               # 游戏数据管理：负责加载和缓存所有游戏数据，提供数据访问接口
│   └── AbilityService.ts                # 属性系统服务：处理属性计算、等级提升和验证，与GameDataService集成
│
├── types/                               # 类型定义目录：定义所有数据结构和接口
│   ├── character.ts                     # 角色数据结构：聚合其他所有类型，定义完整角色模型
│   │                                    # 可以引用其他所有类型文件，但其他文件不能引用它
│   ├── race.ts                          # 种族相关类型：定义种族特性、子种族和种族特有能力
│   ├── Class.ts                         # 职业相关类型：定义职业特性、子职业和职业进阶
│   ├── language.ts                      # 语言系统类型：定义语言类别和语言熟练度
│   ├── leveling.ts                      # 等级系统类型：定义等级进阶规则和经验值计算
│   └── ability.ts                       # 属性系统类型：定义六大属性、调整值和提升规则（合并自attribute.ts）
│
└── utils/                               # 工具函数目录（待创建）：通用功能和辅助方法
    └── dice.ts                          # 骰子模拟：提供各类骰子投掷和计算功能

public/
└── data/                                # 游戏数据目录：存储所有静态游戏数据
    ├── Backgrounds/                      # 背景数据目录：角色背景选项和特性
    │   ├── acolyte.json                 # 侍僧：神殿庇护、宗教知识和医疗特权
    │   ├── charlatan.json               # 骗子：虚假身份、欺诈技巧和伪装能力
    │   ├── criminal.json                # 罪犯：犯罪关系网、潜行和欺骗专精
    │   ├── hermit.json                  # 隐士：发现、医药知识和独处智慧
    │   ├── noble.json                   # 贵族：特权地位、贵族教育和上流社会人脉
    │   ├── sage.json                    # 学者：研究员、博学多识和知识储备
    │   ├── sailor.json                  # 水手：船上地位、航海技能和水手人脉
    │   ├── soldier.json                 # 士兵：军衔、战术训练和军事联系
    │   ├── folk_hero.json              # 民间英雄：平民正义、民众支持和工艺技能
    │   ├── guild_artisan.json          # 公会工匠：公会会员、工艺专精和商业人脉
    │   └── outlander.json              # 化外之民：漫游者、荒野求生和地理知识
    ├── Races/                           # 种族数据目录：各种族的详细定义
    │   ├── dragonborn.json              # 龙裔：龙族血脉、伤害抗性、吐息武器和力量加值
    │   ├── dwarf.json                   # 矮人：矮人韧性、工具熟练、战斗训练和体质加值
    │   ├── elf.json                     # 精灵：魔法和敏捷优势
    │   ├── gnome.json                   # 侏儒：侏儒狡黠、自然幻术、工匠知识和智力加值
    │   ├── half-elf.json                # 半精灵：多面性和魔法
    │   ├── half-orc.json                # 半兽人：凶恶攻击、不屈意志、威吓和力量加值
    │   ├── halfling.json                # 半身人：幸运、灵活、勇敢和敏捷加值
    │   ├── human.json                   # 人类：多面性和适应环境
    │   └── tiefling.json                # 提夫林：地狱抗性、地狱遗赠、黑暗视觉和魅力加值
    ├── Classes/                         # 职业数据目录：各职业的详细定义
    │   ├── barbarian.json               # 野蛮人：狂暴、无甲防御、战斗本能和生命值
    │   ├── bard.json                    # 吟游诗人：魅力施法、激励、专长和法术选择
    │   ├── cleric.json                  # 牧师：神圣领域、引导神力、施法和领域法术
    │   ├── druid.json                   # 德鲁伊：野兽形态、自然施法、结社和环境适应
    │   ├── fighter.json                 # 战士：战斗风格、额外攻击、战技和武器专精
    │   ├── monk.json                    # 武僧：武艺、气、武僧传统和徒手战斗
    │   ├── paladin.json                 # 圣武士：圣武誓言、神圣惩击、光环和誓言法术
    │   ├── ranger.json                  # 游侠：偏好敌人、荒野探索、猎人印记和追踪
    │   ├── rogue.json                   # 盗贼：偷袭、专业技能、诡术和特殊能力
    │   ├── sorcerer.json                # 术士：魔法血统、奥术源泉、变体法术和血脉能力
    │   ├── warlock.json                 # 契术师：魔契、契约赐礼、契约魔法和恶魔赐福
    │   └── wizard.json                  # 法师：奥术学派、法术书、奥术回复和仪式施法
    ├── images/                          # 角色预览图目录
    │   ├── races/                       # 种族预览图
    │   ├── classes/                     # 职业预览图
    │   └── backgrounds/                 # 背景预览图
    ├── localization/                    # 本地化文件：多语言支持和文本资源
    ├── proficiencies/                   # 熟练项数据目录
    │   └── proficiencies.json           # 熟练项定义：技能、工具、武器和护甲
    ├── races/                           # 种族数据目录：各种族的详细定义
    │   ├── dragonborn.json              # 龙裔：龙族血脉、伤害抗性、吐息武器和力量加值
    │   ├── dwarf.json                   # 矮人：矮人韧性、工具熟练、战斗训练和体质加值
    │   ├── elf.json                     # 精灵：魔法和敏捷优势
    │   ├── gnome.json                   # 侏儒：侏儒狡黠、自然幻术、工匠知识和智力加值
    │   ├── half-elf.json                # 半精灵：多面性和魔法
    │   ├── half-orc.json                # 半兽人：凶恶攻击、不屈意志、威吓和力量加值
    │   ├── halfling.json                # 半身人：幸运、灵活、勇敢和敏捷加值
    │   ├── human.json                   # 人类：多面性和适应环境
    │   └── tiefling.json                # 提夫林：地狱抗性、地狱遗赠、黑暗视觉和魅力加值
    └── rules/                           # 规则数据目录：游戏核心规则定义
        ├── leveling.json                # 等级系统规则：经验值要求、等级特性和进阶规则
        └── abilities.json               # 属性系统规则：六大属性定义、调整值表和提升规则

## 开发指南

### 1. 组件开发流程
1. 定义接口和类型
2. 实现核心逻辑
3. 添加错误处理
4. 优化性能
5. 编写测试

### 类型系统使用指南
1. **设计数据结构**
   - 确定存储形式（完整对象/ID引用）
   - 保持类型一致性
   - 避免使用 any 和类型断言

2. **状态管理最佳实践**
   - 使用单一数据源
   - 通过 useEffect 处理派生状态
   - 明确状态更新时机

3. **类型安全保证**
   - 启用严格模式
   - 使用类型守卫代替断言
   - 处理所有可能的类型情况

### 测试规范
- 单元测试：测试独立功能
- 集成测试：验证组件交互
- E2E测试：确保用户流程

### 性能优化
- 使用 useMemo 和 useCallback
- 实现虚拟列表
- 按需加载数据

## Change Log

[Previous entries...]
